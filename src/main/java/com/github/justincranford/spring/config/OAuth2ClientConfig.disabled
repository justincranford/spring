package com.github.justincranford.spring.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;
import org.springframework.security.oauth2.client.userinfo.DefaultOAuth2UserService;
import org.springframework.security.oauth2.client.userinfo.OAuth2UserRequest;
import org.springframework.security.oauth2.client.userinfo.OAuth2UserService;
import org.springframework.security.oauth2.client.web.OAuth2AuthorizedClientRepository;
import org.springframework.security.oauth2.client.web.reactive.function.client.ServletOAuth2AuthorizedClientExchangeFilterFunction;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
@EnableWebSecurity
public class OAuth2ClientConfig {
	private Logger logger = LoggerFactory.getLogger(OAuth2ClientConfig.class);

	@Bean
	public WebClient webClient(ClientRegistrationRepository clients, OAuth2AuthorizedClientRepository authz) {
		final ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2 = new ServletOAuth2AuthorizedClientExchangeFilterFunction(clients, authz);
		return WebClient.builder().filter(oauth2).build();
	}

	@Bean
	public OAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService(final WebClient webClient) {
		final DefaultOAuth2UserService delegate = new DefaultOAuth2UserService();
		return request -> {
			OAuth2User user = delegate.loadUser(request);
//			if (!"github".equals(request.getClientRegistration().getRegistrationId())) {
//				return user;
//			}
			final String login = user.getAttribute("login");
			this.logger.info("OAuth2 login: {}", login);
			return user;

//			OAuth2AuthorizedClient client = new OAuth2AuthorizedClient(request.getClientRegistration(), user.getName(), request.getAccessToken());
//			String url = user.getAttribute("organizations_url");
//			List<Map<String, Object>> orgs = rest
//					.get().uri(url)
//					.attributes(oauth2AuthorizedClient(client))
//					.retrieve()
//					.bodyToMono(List.class)
//					.block();
//
//			if (orgs.stream().anyMatch(org -> "spring-projects".equals(org.get("login")))) {
//				return user;
//			}
//
//			throw new OAuth2AuthenticationException(new OAuth2Error("invalid_token", "Not in Spring Team", ""));
		};
	}

//	public class GitHubOAuth2User extends DefaultOAuth2User {
//		public GitHubOAuth2User(Collection<? extends GrantedAuthority> authorities, Map<String, Object> attributes, String nameAttributeKey) {
//			super(authorities, attributes, "login");
//		}
//	
//	}

	// client
//	@Bean // TODO
//	public ClientRegistrationRepository clientRegistrationRepository() {
//		return new InMemoryClientRegistrationRepository();
//	}
//
	// client
//	@Bean // TODO
//	public OAuth2AuthorizedClientService oauth2AuthorizedClientService(final ClientRegistrationRepository clientRegistrationRepository) {
//		return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);
//	}
//
	// client
//	@Bean // TODO
//	public OAuth2AuthorizedClientRepository oauth2AuthorizedClientRepository() {
//		return new HttpSessionOAuth2AuthorizedClientRepository();
//	}
//
	// client
//	@Bean
//	public ReactiveOAuth2AuthorizedClientManager authorizedClientManager(
//		ReactiveClientRegistrationRepository clientRegistrationRepository,
//		ServerOAuth2AuthorizedClientRepository authorizedClientRepository
//	) {
//		ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =
//			ReactiveOAuth2AuthorizedClientProviderBuilder.builder()
//					.password()
//					.refreshToken()
//					.build();
//
//		DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =
//				new DefaultReactiveOAuth2AuthorizedClientManager(
//						clientRegistrationRepository, authorizedClientRepository);
//		authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
//	
//		// Assuming the `username` and `password` are supplied as `ServerHttpRequest` parameters,
//		// map the `ServerHttpRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
//		authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());
//	
//		return authorizedClientManager;
//	}
//
	// client
//	private Function<OAuth2AuthorizeRequest, Mono<Map<String, Object>>> contextAttributesMapper() {
//		return authorizeRequest -> {
//			Map<String, Object> contextAttributes = Collections.emptyMap();
//			ServerWebExchange exchange = authorizeRequest.getAttribute(ServerWebExchange.class.getName());
//			ServerHttpRequest request = exchange.getRequest();
//			String username = request.getQueryParams().getFirst(OAuth2ParameterNames.USERNAME);
//			String password = request.getQueryParams().getFirst(OAuth2ParameterNames.PASSWORD);
//			if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
//				contextAttributes = new HashMap<>();
//
//				// `PasswordReactiveOAuth2AuthorizedClientProvider` requires both attributes
//				contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
//				contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
//			}
//			return Mono.just(contextAttributes);
//		};
//	}
}